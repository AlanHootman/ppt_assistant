system_prompt: |
  你是一个专业的PPT内容分析专家。请直接分析以下Markdown文本，生成适合PPT制作的完整结构化JSON，无需依赖任何已有的基础解析结果。

template: |
  {% if markdown_text %}
  ## 输入信息
  ### Markdown文本
  ```
  {{ markdown_text }}
  ```
  {% endif %}

  每个部分都需添加以下分析信息：
  1. "semantic_type": 内容的语义类型（见下方详细定义）
  2. "relation_type": 内容之间的关系类型（见下方详细定义）

  ## 1. 结构解析基础规则

  ### 1.1 文档标题解析

  #### 1.1.1 标题识别
  1. **主标题识别**：
     - 主标题通常是文档的第一行文本，可能带有加粗(**文字**)、标题标记(# 文字)等格式
     - 如"**五维导学案：亚洲地图技能及空间认知——你的"地理侦探"必修课**"为主标题

  2. **副标题识别**：
     - 副标题通常位于主标题附近（紧随其后）
     - 副标题可能以"模块主题："、"副标题："、"——"等开头，或是没有特定标记
     - 如果主标题带有"——"分隔符，可能第二部分就是副标题
     - 如"模块主题：地图技能及空间认知"为副标题

  #### 1.1.2 标题长度处理
  1. **精简版本生成**：
     - 为每个超过8个汉字或15个英文字符的标题，提供一个精简版本
     - 精简版本应保留原标题的核心意思，去除修饰词和次要信息
     - 原始标题保存在original_title字段中，精简版标题作为主要title字段
     - 副标题也需遵循相同处理逻辑

  ### 1.2 文档结构识别

  #### 1.2.1 层级结构识别原则
  1. **严格按照Markdown标记识别**：
     - 标题层级结构严格按照Markdown标记(# ## ### #### #####)识别
     - "#"对应level=1，"##"对应level=2，"###"对应level=3，以此类推
     - 每个层级的标题都必须创建独立的节点，保持文档的层级结构

  2. **层级节点要求**：
     - 每个节点都必须包含level字段，明确标识其标题层级
     - 一级标题下的二级标题必须作为section
     - 二级标题下的三级标题必须作为subsection
     - 三级标题下的四级标题必须作为子级subsection
     - 不能将下级标题文本内容并入上级标题的content中

  #### 1.2.2 紧邻标题的处理
  当一个标题(如### 学习目标)紧接着下一级标题(如#### 介绍语)时：
  - 上级标题(学习目标)节点的content应为空数组[]
  - 上级标题节点应包含subsections数组，其中包含下级标题(介绍语)节点
  - 下级标题节点应包含其自身的content数组
  - 这种情况下，上级标题通常为section_header类型，表示一个分组标题
  - 不要将下级标题的内容提升到上级标题的content中
  - 每个标题层级必须保持独立，并保持正确的层级关系

  #### 1.2.3 内容保存原则
  1. **完整性原则**：
     - 原始markdown中的内容要完整保留，不要丢失或合并
     - 保持内容的原始格式和层次关系
     - 不要对特定类型的内容进行特殊处理或重新格式化
     - 必须保留所有标题文本，不要省略任何标题文本

  2. **子部分识别**：
     - 当遇到冒号后跟列表项的格式，应将其视为独立的内容块
     - 正确区分章节标题(###)与加粗文本(**文字**)的区别

  3. **分隔与跳过**：
     - 识别并跳过分隔线(---, ***, ___)，不要将它们解析为内容

  ## 2. 内容结构化规则

  ### 2.1 内容标准化处理

  #### 2.1.1 统一内容对象格式
  所有content数组中的条目必须采用统一的对象格式

  1. **基本类型和内容角色**：
     - "type": 内容的基本类型，必须是以下类型之一：
       - "paragraph" - 连贯的文本段落
       - "bullet_list" - 无序列表
       - "numbered_list" - 有序列表

  2. **文本段落格式**:
     ```json
     {
       "type": "paragraph", 
       "content": "文本内容", 
       "word_count": 字数
     }
     ```

  3. **无序列表格式**:
     ```json
     {
       "type": "bullet_list", 
       "items": [
         {"content": "列表项1", "word_count": 字数},
         {"content": "列表项2", "word_count": 字数}
       ],
       "item_count": 项目数量,
       "total_word_count": 总字数
     }
     ```

  4. **有序列表格式**:
     ```json
     {
       "type": "numbered_list", 
       "items": [
         {"content": "列表项1", "word_count": 字数},
         {"content": "列表项2", "word_count": 字数}
       ],
       "item_count": 项目数量,
       "total_word_count": 总字数
     }
     ```

  #### 2.1.2 内容计数统计
  1. **计数信息要求**：
     - 对于每种内容类型，必须添加相应的计数信息：
       - 文本段落：添加word_count字段，计算字符数
       - 列表内容：添加item_count字段计算列表项数量，total_word_count字段计算总字数，并为每个列表项添加word_count

  2. **节点统计信息**：
     - 每个section和subsection必须添加content_stats字段，包含：
       - "total_word_count": 该节点下所有内容的总字数
       - "element_count": 内容元素总数（文本段落、列表等）
       - "content_types": 该节点包含的内容类型列表

  #### 2.1.3 文本分段与长度控制
  1. **长度检测**：
     - 检测超长段落（超过150个字符），建议在合适位置分段
     - 对于长文本，记录每个自然段的字数，便于后续布局决策

  ### 2.2 内容节点统计

  每个章节必须添加content_stats字段，包含：
  - "total_word_count": 该章节下所有内容的总字数（不包括子节点）
  - "element_count": 内容元素总数（文本段落、列表等）
  - "content_types": 该章节包含的内容类型列表

  ## 3. 标记清理规则

  ### 3.1 Markdown标记清除

  #### 3.1.1 文本标记清理
  1. **清除所有文本内容中的Markdown标记符号**：
     - 删除标题标记：去除文本开头的所有"#"符号及其后的空格（如"### 标题"→"标题"）
     - 删除加粗标记：去除文本中的"**"符号（如"**加粗文本**"→"加粗文本"）
     - 删除斜体标记：去除文本中的"*"和"_"符号（如"*斜体*"→"斜体"）
     - 删除代码块标记：去除```和`符号
     - 删除链接标记：将"[链接文本](URL)"格式转换为纯文本"链接文本"
     - 删除图片标记：将"![alt文本](URL)"格式转换为描述"alt文本"

  #### 3.1.2 标题文本清理规则
  1. **标题清理**：
     - 确保所有章节、子章节的title字段不包含"#"标记符号
     - 如"#### 介绍语"应转换为纯文本"介绍语"作为title
     - 对于加粗的标题如"**标题**"，应仅保留"标题"

  #### 3.1.3 内容文本清理规则
  1. **内容清理**：
     - content数组中的所有文本条目都必须去除Markdown标记
     - 列表项中的文本也要清除所有Markdown格式符号
     - 保留文本的语义和内容，只去除格式符号
     - 必须保留原始文本中的换行符(\n)，不要将多行文本合并为单行

  ## 4. 语义分析规则

  ### 4.1 内容语义类型(semantic_type)与关系类型(relation_type)定义

  #### 4.1.1 内容语义类型(semantic_type)
  {{ SEMANTIC_TYPES }}

  #### 4.1.2 内容关系类型(relation_type)
  {{ RELATION_TYPES }}

  ### 4.2 语义类型判断

  {{ SEMANTIC_TYPE_GUIDELINES }}

  ### 4.3 关系类型判断

  {{ RELATION_TYPE_GUIDELINES }}

  ### 4.4 类型标注综合规则

  #### 4.4.1 空内容章节处理
  对于只有标题而没有实际内容的章节(content为空数组且紧跟着下级标题)：
  - 应设置semantic_type为"section_header"
  - 这些章节通常适合作为PPT中的章节分隔页或分组标题

  #### 4.4.2 语义特征判断
  语义类型和关系类型必须反映内容的实际特征，不要为空内容随意赋予语义特征

  #### 4.4.3 复杂结构章节
  对于复杂结构的章节：
  - 当一个章节包含多个小节(如"成功案例"和"失败案例")时，应确保上层章节的relation_type反映出这种结构关系
  - 例如包含"成功案例"和"失败案例"的章节，其relation_type应设为comparison
  - 上层章节的relation_type应能明确表示其下属子章节之间的关系

  ## 5. 输出结构规范

  ### 5.1 整体结构范例
  ```json
  {
    "title": "文档标题精简版（超过8个中文字符或15个英文字符时必须提供）",
    "original_title": "文档原始完整标题",
    "level": 1,
    "subtitle": "文档副标题精简版（超过8个中文字符或15个英文字符时必须提供）",
    "original_subtitle": "文档原始完整副标题(如有)",
    "sections": [
      {
        "title": "目标与任务导学设计",
        "original_title": "目标与任务导学设计",
        "level": 2,
        "content": [],
        "content_stats": {
          "total_word_count": 0,
          "element_count": 0,
          "content_types": []
        },
        "semantic_type": "section_header",
        "relation_type": "hierarchical",
        "subsections": [
          {
            "title": "引导问题",
            "original_title": "引导问题",
            "level": 3,
            "content": [
              {
                "type": "paragraph",
                "content": "引导词：看一看\n设疑问题：北京的暴雨淹没街道、新疆的葡萄因冰雹绝收…这些极端天气背后，藏着亚洲怎样的地理密码？\n回答：（留白）",
                "word_count": 100
              }
            ],
            "content_stats": {
              "total_word_count": 100,
              "element_count": 1,
              "content_types": ["paragraph"]
            },
            "semantic_type": "instruction",
            "relation_type": "problem_solution"
          }
        ]
      }
    ]
  }
  ```

  ### 5.2 关键规范要点
  1. 所有内容必须采用统一的对象格式体系，按照type来组织
  2. 每个内容对象必须包含适当的计数信息（如word_count、item_count、total_word_count等）
  3. 章节层级结构必须严格保持，主章节下的subsections不能丢失或错误归类

jinja_args:
  - markdown_text
  - SEMANTIC_TYPES
  - RELATION_TYPES
  - SEMANTIC_TYPE_GUIDELINES
  - RELATION_TYPE_GUIDELINES

use_model: deep_thinking
return_json: true 